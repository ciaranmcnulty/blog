<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Dans Blog]]></title>
    <link href="/blog/categories/php.xml" rel="self"/>
    <link href="/"/>
    <updated>2019-07-23T21:12:22+01:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Make Timesheet Parser with Hoa Compiler]]></title>
            <link href="/blog/2019/02/11/timesheet-parser-hoa-compiler/"/>
            <updated>2019-02-11T00:00:00+00:00</updated>
            <id>/blog/2019/02/11/timesheet-parser-hoa-compiler/</id>
            <content type="html"><![CDATA[<p>I have been keeping my timelogs in a plain-text timesheet format as follows:</p>

<pre><code class="bash">2019-02-11
09:00 [JIRA-1234] Adding some functionality
10:00 [standup]
10:15 [JIRA-1234] Fixing that annoying bug
11:00 [JIRA-2134] Review
12:00 [lunch]
13:00 [JIRA-1234] @pairing
14:00 [confused]
18:00 [finish]

2019-02-12
09:00 ...
</code></pre>

<p>Bascially, it's much quick to log my time realistically. I don't need to
continually break my concentration and assign time to tickets as I work on
them, or strain to remember (or make up) what I did at the end of the day, or
even at the end of the week. It also means I can record what <em>really</em>
happened, and not just logging random events on the <code>ZZ-22</code> "catch-all" ticket
where the information is lost to the powers of analysis.</p>

<p>The only problem is that every week I need to translate this into not one but
two JIRAs, this is an operation that involves a huge amount of <em>clicking</em> and
<em>waiting</em> and <em>confusion</em> and <em>ppaaiinn</em>.</p>

<p>So, pain once a week instead of pain every day. But there is no reason that
this situation cannot be ameliorated - we can <em>parse the timesheet</em>. Once we
parse the timesheet we can sync it automatically with JIRA and my Monday
morning trauma is at an end, and our project managers can be happier as I can
accurately curate and log my time every day effortlessly.</p>

<p>And, the miscellaneous tickets can <em>still</em> be assigned to a bucket ticket, but
at least the original information is preserved,</p>

<h2 id="parsing-the-timesheet">Parsing the Timesheet</h2>

<p>Why do we want to parse the timesheet? We want to extract the information from
it, and eventually produce a data structure <em>like</em>:</p>

<pre><code>[
    '2019-01-01' =&gt; [
        'entries' =&gt; [
            [ 'time' =&gt; '10:00', 'category' =&gt; 'AN-1234', 'comment' =&gt; 'foobar' ],
            [ 'time' =&gt; '11:00', 'category' =&gt; 'lunch', 'comment' =&gt; 'foobar' ],
        ]
    ],
    '2019-01-02' =&gt; [
        'entries' =&gt; [
            [ 'time' =&gt; '10:00', 'category' =&gt; 'AN-456', 'comment' =&gt; 'foobar' ],
        ]
    ]
]
</code></pre>

<p>Once we have structured data we can <em>do something useful with it</em>.</p>

<p>We could use regular expressions to extract the data, but, well, it might not end well.
Instead we are going to use a <em>compiler</em> and we are not going to write any PHP
code at all.</p>

<h2 id="the-hoa-compiler">The HOA Compiler</h2>

<p>The <a href="https://github.com/hoaproject/Compiler">HOA
Compiler</a>. The HOA Compiler is an
amazing library which can take a grammar in the form of a <code>.pp</code> file (see
<a href="https://hoa-project.net/En/Literature/Hack/Compiler.html#PP_language">here</a>
for good and detailed documentation).</p>

<p>The timesheet <code>document</code> is composed of one or more <code>date</code> entries (of the
form <code>YYYY-MM-DD</code>) and each date entry consequently contains a list of <code>entry</code>
items, each defining the <code>time</code>, and optionally a <code>category</code>, <code>comment</code> and
one or more <code>tags</code>.</p>

<p>Let's skip straight to it:</p>

<pre><code>%token newline            \n
%token space              \s
%token date               [0-9]{4}-[0-1][0-9]-[0-3][0-9] -&gt; entry

%token entry:time         [0-9]{1,2}:[0-9]{1,2}
%token entry:break        \n\n -&gt; default
%token entry:newline      \n
%token entry:space        \s
%token entry:text         [a-zA-Z0-9'"\h.-]+
%token entry:tag          @[a-zA-Z0-9-_]+
%token entry:bracket_     \[ -&gt; category

%token category:name      [A-Za-z-_0-9]+
%token category:_bracket  \] -&gt; entry

#document:
    date()*

#date:
    &lt;date&gt; &lt;newline&gt;? entry()*

#entry:
    &lt;time&gt; &lt;space&gt;? category()? &lt;space&gt;? &lt;text&gt;? tag()* (&lt;newline&gt; | &lt;break&gt; )?

#category:
    &lt;bracket_&gt; &lt;name&gt; &lt;_bracket&gt;

#tag:
    &lt;space&gt;? &lt;tag&gt;
</code></pre>

<p>So first we have the tokens, which are PCRE (regex) patterns. These define
<em>lexemes</em> the which are like the "atoms" of our grammar. We then define the
<em>rules</em> which combine these atoms - when prefixed with <code>#</code> become <em>nodes</em> in
the AST (more on this later). Note the following:</p>

<ul>
<li>The document has <em>zero or many</em> (<code>*</code>) <code>date()</code> rules.</li>
<li>Each <code>date()</code> rule is composed of a <code>&lt;date&gt;</code> followed by <em>zero or one</em> (<code>?</code>)
newlines, followed by one or many <code>entry()</code> rules.</li>
<li>Each <code>entry()</code> rule must have a valid <code>&lt;time&gt;</code> token, followed by one or zero
spaces, followed by a <code>category()</code> rule, followed by... etc.</li>
</ul>

<p>Did you notice the <code>-&gt;</code> symbols? These are <em>namespace</em> transitions, they mean
that, when encountring a <code>date</code> token the lexer should switch to the <code>date</code>
namespace - and it will then <em>only</em> consider tokens in this namespace, this is
necessary to stop rules conflicting (you don't want to interpret a <code>date</code>
token in a <code>category</code> for example). The Compiler also allows you to transition
to the previous namespace using <code>__shift__</code> (see the
<a href="https://hoa-project.net/En/Literature/Hack/Compiler.html#PP_language">docs</a>
for more info).</p>

<p>When there is no namespace, the <code>default</code> namespace is implicitly used. 
When there is a <code>break</code> token in the <code>date</code> namespace (two new lines as
defined above) we revert back to the <code>default</code> namespace and can consider f.e.
the <code>date</code> token again.</p>

<p>Namespaces are essential, and are what really help make the compiler a much
better option than simple regular expressions.</p>

<p>You may notice that we parse the category as a rule, and the tag as a token.
There is no particular reason for this other than laziness - we could also
have parsed the category as a token, or the tag as a rule, but let's look at
the difference when the AST is rendered:</p>

<p><strong>Tag</strong>:</p>

<pre><code class="bash">#tag
&gt;  token(entry:space,  )
&gt;  token(entry:tag, @barfoo)
</code></pre>

<p><strong>Category</strong>:</p>

<pre><code class="bash">#category
&gt;  token(entry:bracket_, [)
&gt;  token(category:name, AA-1234)
&gt;  token(category:_bracket, ])
</code></pre>

<p>The information we really want from the above two examples is the name -
<code>barfoo</code> and <code>AA-1234</code> respectively. With the category we can easily
extract this information from the token in the AST, but with the tag we need
to perform additional processing (e.g. <code>ltrim('@barfoo', '@')</code>) in order to
obtain the tag name (<code>barfoo</code>), with the category it is less trivial.</p>

<p>But wait, how did we get here?</p>

<h2 id="parsing-the-timesheet">Parsing the Timesheet</h2>

<p>In order to do anything useful, we want to get our hands on an AST (<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract
Syntax Tree</a>). This will
be the data structure containing all of our data, more-or-less neatly
organized into a tree structure of nodes (remember these are defined in the
grammar with the <code>#</code> prefix, e.g. <code>#entry</code>), each node contains the set of
tokens (and their values) defined in the rule.</p>

<p>We use the HOA Compiler as follows:</p>

<pre><code class="php">use Hoa\Compiler\Llk\Llk;
use Hoa\File\Read;

$compiler = Llk::load(new Read(__DIR__ . '/../../resources/timesheet.pp'));
$ast = $compiler-&gt;parse($string);
// profit!
</code></pre>

<p>Once we have the AST we can visualize it using the <code>Dumper</code> class provided by
HOA:</p>

<pre><code class="php">use Hoa\Compiler\Visitor\Dump;

$dumper = new Dump();
echo $dumper-&gt;visit($ast);
</code></pre>

<p>Producing something like this:</p>

<pre><code class="bash">&gt;  #document                             
&gt;  &gt;  #date                                 
&gt;  &gt;  &gt;  token(date, 2019-01-01)                       
&gt;  &gt;  &gt;  token(entry:newline,             
)                                           
&gt;  &gt;  &gt;  #entry                                                                                                                       
&gt;  &gt;  &gt;  &gt;  token(entry:time, 10:00)   
&gt;  &gt;  &gt;  &gt;  token(entry:space,  )           
&gt;  &gt;  &gt;  &gt;  token(entry:text, Fo)                                                                                                     
&gt;  &gt;  &gt;  &gt;  token(entry:newline,                     
</code></pre>

<h2 id="walking-the-ast">Walking the AST</h2>

<p>The AST variable has type <code>TreeNode</code> and can be traversed easily with helper
methods such as <code>getChildren()</code>, to do something useful with it, you will
probably want to <em>walk the tree</em>, the basic idea is something like the
following:</p>

<pre><code class="php"><br />class TreeWalker
{
    public function walk(TreeNode $node): array
    {
        $dates = [];
        foreach ($node-&gt;getChildren() as $childNode) {
           if ($childNode-&gt;getId() === 'date') {
               $dates[] = $this-&gt;walkDate($childNode);
           }
        }

        return $dates;
    }

    private function walkDate(TreeNode $node): array
    {
        $date = [
            'entries' =&gt; [],
        ];

        foreach ($node-&gt;getChildren() as $childNode) {
            if ($childNode-&gt;getValueToken() === 'date') {
                $date['date'] = new DateTimeImmutable($childNode-&gt;getValueValue()));
            }

            if ($childNode-&gt;getId() == 'entry') {
                $date['entries'][] = $this-&gt;walkEntry($childNode));
            }
        }

        return $date;
    }

    private function walkEntry(TreeNode $node): array
    {
        // etc.
    }
}
</code></pre>

<p>The result would be <em>something</em> like:</p>

<pre><code class="php">[
    'date' =&gt; '2019-21-13',
    'entries' =&gt; [
        [
            // ...
        ],
        [
            // ...
        ]
    ],
    'date' =&gt; '2019-21-14',
    'entries' =&gt; [
        [
            // ...
        ],
        [
            // ...
        ]
    ],
]
</code></pre>

<p>This is a simplified version, see
<a href="https://github.com/dantleech/timekeeper/blob/master/lib/Adapter/Hoa/TimesheetWalker.php">here</a> for the complete version.</p>

<p>Note that we progressively build our data set and extract information from the
tokens in the tree.</p>

<h2 id="summary">Summary</h2>

<p>Now that we have walked the AST we have a data structure suited to our needs,
and the next step is to build some rudimentary reporting and then integrate
with the JIRA API. Along the way the above will probably change significantly -
but fortunately it is now <em>easy</em> to change.</p>

<p>The official documentation provides a much greater depth of knowledge than
this blog post does, but it is perhaps useful to see it explained from a
different perspective.</p>

<p>Here is to great and future hopes of increased productivity powered by
<a href="https://hoa-project.net/En/">HOA</a>.</p>
]]></content>
        </entry>
    </feed>